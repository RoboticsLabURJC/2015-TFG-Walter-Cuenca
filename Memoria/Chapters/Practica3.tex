% Chapter TiendaWEB

\chapter{Tienda Web} % Main chapter title
\section{Enunciado}
\subsection{Requisitos}
\subsubsection*{Apariencia}
\subsubsection*{Funcionalidad}
\subsection{Tecnologias Necesarias}
\begin{enumerate}
\item Django.
\item Tecnologias comunicacion cliente-servidor asincrono
\item WebServices
\item BBDD(Base de Datos)
\end{enumerate}
\subsection{Objetivos}
La aplicacion tiene que cumplir los siguientes caracteristicas:
\begin{enumerate}
\item EL proyecto tiene que contener varias: url's,modelos y vistas.
\item Gestion de usuarios : Login,Registro y Perfil individual
\item Utilizacion de contenido multimedia
\item Autocompletado.
\item Implemencion de webService
\item Carrito de la compra.
\item Formularios : validaciones y generacion.
\end{enumerate}
\section{Tecnologias aplicadas}
En este punto se explica los elementos que emplearemos de cada tecnologia en el desarrollo de esta practica.
\subsection{BBDD}
Para acceder/guardar informacion de los usuarios o del contenido de la web es necesario utilizar una BBDD com punto de almacenaiento de toda esta informacion.
\\Por lo general, cuando se genera una aplicacion con Django la BBDD que segenera es Sqlite3 ,en nuestro caso vamos a implementar Mysql al ser una de la BBDD mas utilizadas en este momento.
\\Por ello,necesitamos modificar el fichero 'setting' del proyeccto en el cual la informacion de  la BBDD que vamos a utilizar.
\begin{lstlisting}[
frame=single,
commentstyle=\color{CadetBlue},
captionpos=b,
caption=Conexion base de datos.]
 DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'prueba',
        'USER':'root',
        'PASSWORD':'*******',
        'HOST':'',
        'PORT':'',
    }
}
\end{lstlisting}
\subsection{Django}
Es un framework que nos permite desarrollar una aplicacion web de una forma ordenada y secilla. Se basa en un MVC,es decir, modelo-vista-controlador que son las principales puntos en los que se basa el framework.
\subsubsection{Models}
Los modelos se representan como una clase Python ya que nos permite expresar de la misma forma multiples motores de bases de datos.
\\Cada objeto se basa en el objeto 'models.Model' que contienen todas las herramientas necesarias para hacer que estos objetos interactuen con la base de datos de forma compacta.
\begin{lstlisting}[
frame=single,
commentstyle=\color{CadetBlue},
captionpos=b,
caption=Ejemplo de un Modelo.]

 from django.db import models
 
 class Artista(models.Model):
  name = models.CharField(max_length=100,null=True)
  linkImg = models.ImageField(upload_to="img_artist/",null=True)
  genero = models.CharField(max_length=100,null=True)
  web = models.URLField(max_length=100,null=True)
  disco = models.ManyToManyField(disco)
  videos = models.ManyToManyField(Videos) 
  galeria = models.ManyToManyField(Imagenes)
  
  def __unicode__(self):
   return self.name
\end{lstlisting}
Para definir cada una de las propiedades utilizamos el objeto 'models.Model' de Django el cual informa al framework que se trata de un modelo y por tanto lo tiene que guardar en la base de datos.
\\El siguiente paso se definen cada una de las propiedades como el name,linkImg,genero,...el cual define el tipo de campo:
\begin{itemize}
\item models.CharField : permite definir texto.
\item models.UrlField : permite definir una url.
\item models.ImageField : permite define una imagen.Es necesesario definir donde localizar el contenido pasando el atributo 'upload\_to'.
\item models.DateTimeField : esto define fecha y hora.
\item models.ForeignKey : permite vincularse a otro modelo estableciendo una relacion 1 a 1.
\item models.ManyToManyField : permite vincularse a otro modelo con una relacion 1 a n.
\end{itemize}
Tras la creacion de los campos de cada clase se pueden definir funciones propias.En nuestro ejemplo utilizamos '\_\_unicode\_\_'  que devuelve el valor del campo nombre del objeto.
\\Generalmente cada uno de  las clases se convierte en una tabla de la base de datos aunque si el metodo posee una relacion muchos-a-muchos se crea una tabla auxiliar entre los modelos.
\\imagen de una tabla intermedia
\\Para generar las tablas es necesario incluir los modelos en el fichero 'manage.py'.
\\generacion de las tablas 
\subsubsection{Vistas}
Es uno de los punto mas importante ya que contiene toda la logica necesario para interactuar con la base de datos y devolver por lo general una pagina web con ayuda de pantillas que mas adelante se explicara su funcionamiento.
\\Las vistas se encuentran del archivo 'models.py' del proyecto.
\begin{lstlisting}[
frame=single,
commentstyle=\color{CadetBlue},
captionpos=b,
caption=Ejemplo de vistas.]
 from django.http import HttpResponse 

 def EventSelect(request,evento):
  event = Evento.objects.filter(name__startswith=evento)
  return render(request,'IndexEvent.html',{'event':event})
    
 def IndexView(request):
  list_video=Videos.objects.all()
  return render(request,'fullVideo.html',{'list_video':list_video})
\end{lstlisting}
Cada de las vistas se crean a traves de una funcion definida en pyton  en las que distinguimos dos tipos :
\begin{itemize}
\item Dinamicas : son aquellas que reciben un parametro adicional a traves de la url como por ejemplo la funcion 'def EventSelect(request,event)'.Esta funcion recibe el parametro event a traves de la url asociada a ella.
\item Estaticas : son aquellas que reciben solo como parametro la peticion a traves del parametro 'request' como por ejemplo la funcion 'def IndexView(request)'.
\end{itemize}
Con la informacion que recibe se realiza una consulta con la BBDD obteniendo la informacion requerida.A traves del metodo 'render(request,'doc.html',info)' que recibe como parametros la peticion,el nombre del documento html(plantilla) y la informacion de la consulta se consigue mostrar la informacion al usuario como una pagina web.

\subsubsection{Controlador}
En este modelo el controlador tiene como funcion seleccionar la vista que corresponde a la peticion del usuario.
\\Por ello al crear la aplicacion se genera el archivo 'urls.py' que contiene todas las direcciones disponibles.
\begin{lstlisting}[
frame=single,
commentstyle=\color{CadetBlue},
captionpos=b,
caption=Ejemplo de url's.]

 from django.conf.urls.defaults import patterns, url
 from .views import ....

 urlpatterns = patterns('',
 	url(r'^index/$',  views.MainPage),
	url(r'^eventos/(?P<evento>\w{1,50})/$',  views.EventSelect),
 )
\end{lstlisting}
Dentro de la vaiable 'urlpattern' se introducen las direcciones como una dupla con los siguientes parametros:
\begin{itemize}
\item path url : define el formato de la direccion.
\item vista : define el nombre de la vista que se ejecuta cuando se realiza una consulta al path asociado.
\end{itemize}
En nuestra aplicacion se define dos tipos de path como se explican a continuacion :
\begin{itemize}
\item Dinamincos : son aquellos que permiten definir un parametro dentro del path que influye en respuesta.
\\Del ejemplo anterio,el path '(r'\^ eventos/(?P<evento>\\w{1,50})/\$, ...)' define el nombre a traves de '?P<evento>' y el tipo y longitud a traves de la varible de 'w{1,50}',en nuestro caso es de tipo string con una longitud maxima de 50 caracteres.
\item Estaticos : son aquellas que siempre obtinen las misma respusta al acceder a ellas ya que no reciben ningun parametro.Del ejemplo anterior el path '(r'\^index/\$',...)' es de este tipo.
\end{itemize}
\subsubsection{Sistema Plantillas}
Una plantilla define rellenos y permite utilizar etiquetas de plantilla que indican como se debe de mostrar el documento.Por lo general, se utiliza para generar documentos HTML aunque se puede generar cualquier tipo de documento basado en texto.
\begin{lstlisting}[
frame=single,
commentstyle=\color{CadetBlue},
captionpos=b,
caption=Ejemplo plantilla .]
 <!DOCTYPE html>
 <html>
  <head>
   <title>Hora actual</title>
  </head>
  <body>
   <h1>Bienvenidos</h1>
    <p>Dia y hora actual: {{ fechahora\_actual }}</p>
    {% for cantante in evento.artistas.all %}
     <div>
      <a href="pulpitrock.jpg" class="thumbnail">{{cantante.name}}</p></a>
     </div>
    {% endfor %}
    {% block info %}
    {% endblock %}
  </body>    
</html>
 {% extends 'IndexApp.html' %}
\end{lstlisting}
La plantilla del ejemplo muestra las caracteristicas de las que se pueden llevar:
\begin{itemize}
\item El contenido encerrado entre \{\{ \}\} es una variable obtenida a partir de la vista correspondiente
\item El contenido encerrado entre \{\% \%\} hace referencia a las etiquetas de plantilla permitiendo dotar a las plantillas de algun mecanismo simple de programacion.
\end{itemize}
Se puede definir varias tipos de etiquetas y filtros disponibles en la creacion de las plantillas.
\\Definir por cada enlace un documeto HTML seria algo muy pesado y segun la complejidad del proyecto esto llega ser inviable por ello en Django existe la definicion de herencia.
\\Esta propiedad permite definir una plantilla base con secciones de codigos que marcan las diferencias entre las distintas paginas a traves de las siguienes etiquetas \{\% block seccion1 \%\} y  \{\% endblock \%\}.Las paginas hijas heredan la estructura del padre a a traves de  \{\% extends 'IndexApp.html' \%\} y pasamos a sobreescribir cada una de las secciones anteriores por el contenido correspondiente.
\subsection{Tecnologias comunicacion cliente-servidor}
Para establecer comunicacion entre el cliente-el servidor existen tecnologias quer permiten que el usuario interactue con el servidor ya sea solicitando,validando o guardando algun tipo de informacion. \\En nuestra practica vamos a utilizar las siguientes tres tecnologias.
\subsubsection*{Ajax}
Permite realizar peticiones asincronas al servidor,es decir,son peticiones que se encargan de realizar una consulta al servidor y el resultado se presenta en una seccion de la pagina dando lugar a no cargar la pagina entera para poder mostrar el nuevo contenido.
\\Existen multiples formas de integra Ajax ya se utilizando el objeto XHTML.... a traves de JavaScript o empleando Jquery que disponde de metodo \$.ajax(......).Por facilida se emplea Jquery ya que nos permite realizar la peticion y presentar su resultado de una forma mas sencilla.
\subsubsection*{Cookie}
Para guardar informacion de estado del usuario durante su instancia en la web es necesario emplear Cookies debido a que el protocolo Http  no es capas de guardar este tipo de informacion.
\\En nuestra aplicacion es necesario guardar la compra de los elementos de la web 
\subsubsection*{Formularios}
Tienen como funcion validar/guardar informacion que los usuarios.
\\Disponemos de dos tipos principales Get y Post.El metodo Get se utiliza para solicitar acceso a un terminado punto de la aplicacion por lo que el usuario recibe un formulario vacio , mientras que el metodo Post se utiliza cuando el usuario ha rellenado un formulario y es envia al servidor el cual obtendra cada uno  del los campos para ser validados y permitan al usuario el acceso.
\\En la aplicacion se utiliza esto para desarrollar los siguientes puntos:
\begin{enumerate}
\item Register,Login de usuarios.
\item Modificacion perfil de cada usuario.
\item Contacta para la peticion de informacion sobre la web
\end{enumerate}
\subsection{WebServices}
Son servidores externos que contienen informacion guardada en su BBDD.Generalemente, se realizan peticion a una direccion donde el cuerpo del mensaje tiene que tener la estructura predefinida por el WebServices.
\\El formato de los datos pueden ser Json o XML segun las caracteristicas del Servidor Web. 
\section{Desarrollo}
EL desarrollo de una Web consta de tres secciones en la que cada una se encarga de aportar funcionalidad a la web.A continuacion se pasa explicar el enfoque dado de cada parte en nuestra practica.
\subsection{Back-End}
Se encarga de la creacion de tablas y campos de la BBDD.
Ademas,desarrolla mecanismos que permitan realizar consultas contra la BBDD o enviar cierta informacion al usuario.
\subsubsection*{Modelos}
Definimos los modelos necesarios para tratar el contenido de la aplicacion.A continuacion,se muestra los campos y la relacion existente entre los modelos.
\\IMAGEN DE LA RELACION DE BASES DE DATOS
\\Tras la creacion de los modelos se incluyen dentro del archivo 'manage.py' para permitir que sean visibles en el adminitrador de Django.
\\IMAGEN DEL ADMIN DE DJANGO
\\El ultimo paso es introducir informacion en cada modelo a traves del interfaz  Admin de Django el cual es intuitivo e independiente de la BBDD que utilizamos. 
\\IMAGEN DE LA INTRODUCCION 
\subsubsection*{URL's}
El siguiente paso es generar el conjunto de rutas de las que dispone la aplicacion permitiendo al usuario acceder al contenido correspondiente.
\\imagen urls
\subsubsection*{Vistas}
Ahora es necesario crear las vistas encargadas de obtener/introducir informacion a la BBDD.A continuacion se explica la funcionde las distintas funciones que se han creado.
\subsubsection*{\textit{Index Page}}
Al acceder a la pagina principal el servidor una peticion que sera tratada por la vista 'Index Page'.
\\Esta vista obtiene la informacion de los eventos,artistas disponibles en la aplicacion y asi el usuario lo pueda visualizar.
\begin{lstlisting}[
frame=single,
commentstyle=\color{CadetBlue},
captionpos=b,
caption=Ejemplo plantilla .]
def IndeApp(request):
 return render 
\end{lstlisting}
\subsubsection*{Select Festival}
Al seleccionar un festival se envia la peticion y el nombre del festival al servidor el cual ejecutara la vista 'SelecT\_Event'.
\\La vista busca dentro de la tabla 'Eventos' una coincidencia con el nombre del festival de la peticion, esta informacion se envia al cliente para que su visualizacion.
\begin{lstlisting}[
frame=single,
commentstyle=\color{CadetBlue},
captionpos=b,
caption=Ejemplo plantilla .]
def IndeApp(request):
 return render 
\end{lstlisting}
\subsubsection*{Select Cantante}
La funcion de esta esta vista es similar a la explicada en anteriormente aunque la consulta se realiza sobre la tabla 'Cantantes' de la BBDD.
\begin{lstlisting}[
frame=single,
commentstyle=\color{CadetBlue},
captionpos=b,
caption=Ejemplo plantilla .]
def IndeApp(request):
 return render 
\end{lstlisting}
\subsubsection*{Imagenes}
Al seleccionar visualizar la galeria de la web el servidor una peticion que sera trata por la vista 'IndexImage'.
\\La vista consulta la tabla 'Imagenes' cuya informacion sera devuelta al cliente.
\begin{lstlisting}[
frame=single,
commentstyle=\color{CadetBlue},
captionpos=b,
caption=Ejemplo plantilla .]
def IndeApp(request):
 return render 
\end{lstlisting}
\subsubsection*{Videos}
La funcion de esta vista es similar a la explicada en anteriormente aunque la consulta se realiza sobre la tabla 'Videos' de la BBDD.
\begin{lstlisting}[
frame=single,
commentstyle=\color{CadetBlue},
captionpos=b,
caption=Ejemplo plantilla .]
def IndeApp(request):
 return render 
\end{lstlisting}
\subsubsection*{Buscador}
Al realizar una peticion a traves de la barra de busqueda el servidor recibe una perticion que sera tratada por la vista 'Search'.Esta funcion busca en las distintas tablas (artistas,festivales) el elemento solicitado en caso en no encontrarlo se envia la cadena 'No resultado' en caso contrario enviamos lla informacion obtenida.
\begin{lstlisting}[
frame=single,
commentstyle=\color{CadetBlue},
captionpos=b,
caption=Ejemplo plantilla .]
def IndeApp(request):
 return render 
\end{lstlisting}
\subsubsection*{Gestion de usuarios}
La gestion de usuarios esta enfocado en permitir a los usuarios formar parte de la web o permitir acceder a la informacion del usuario.
\\Por ello,cuando un usuario quiere formar parte de la web por primera vez envia una peticion al servidor que sera tratada por la vista 'IndexRegister'.La vista evalua el metodo de la peticion que puede ser:
\begin{itemize}
\item GET :peticion de contenido.
\item POST :validar/guardar informacion enviada del cliente-servidor.
\end{itemize}
En nuestra aplicacion al tener un metodo 'GET' enviamos un formulario para que el cliente lo rellene con los datos solicitados.
\\En caso de ser 'POST' se genera una instancia del formulario 'Register()'con la informacion que viaja en el cuerpo de la peticion. Tras esto se valida el contenido del fomulario a traves del metodo 'is\_vaid()' y en caso de pasar la validacion se obtiene la informacion del formulario con el metodo 'cleaned\_data['nameVar']' y creamos un nuevo elemento en la tabla User con la informacion anterior.
\\Finalmente,se crea una nueva entrada en la table 'UserProfile' al que se le asocia la entrada de la tabla 'User' creada y el sexo del usuario.
\begin{lstlisting}[
frame=single,
commentstyle=\color{CadetBlue},
captionpos=b,
caption=Vista registro de usuarios.]
 def indexRegister(request):
  if request.method == 'POST':
   formRegister = Register(request.POST)
    if formRegister.is_valid():
     user = formRegister.cleaned_data['nick']
     nombre = formRegister.cleaned_data['nombre']
     apellido = formRegister.cleaned_data['apellido']
     password = formRegister.cleaned_data['pasword']
     email = formRegister.cleaned_data['email']
     sex = formRegister.cleaned_data['sexo']
     u=User.objects.create_user(
      username=user,email=email,password=password,
      first_name=nombre,last_name=apellido)
     #guardamos el usuario y pasamos a crear el perfil
     perfil = UserProfile(user=u,sexo=sex)
     perfil.save();
     return HttpResponseRedirect('/recursos/login')
   else:
     error = 'La informacion no es valida'
  return render(request,'new_user.html',{'form':Register()})
\end{lstlisting}
Por otra parte los usuarios que quieran acceder a la web a traves del login envian una peticion al servidor que sera tratada por la vista 'indexLogin'.Al igual que con la vista anterior evaluamos el metodo de la peticion.
\\En caso de ser 'GET' se envia un formulario de tipo 'FormLogin' con los campos necesarios para iniciar sesion. Mientras que al ser 'POST' la validacion del formulario  y la obtencion de informacion se realiza de la misma forma que en el caso anterior.
\\Se realiza la autenticacion del usuario mediante el metodo 'autenticate()' de Django tras esto pasamos a hacer login en la aplicacion a traves del metodo 'login()' de Django.Al final se a침ade una  cookie en la respuesta con el nombre del usuario con el objetivo de emplearla para mantener informacion del usuario.
\begin{lstlisting}[
frame=single,
commentstyle=\color{CadetBlue},
captionpos=b,
caption=Vista login usuarios.]
def indexLogin(request):
 if request.method == 'POST':
  FormLogins = FormLogin(request.POST)
   if FormLogins.is_valid():
    user = FormLogins.cleaned_data['nombre']
    password = FormLogins.cleaned_data['pasword']
    usuario = authenticate(username=user,password=password) 
    if usuario is not None and usuario.is_active:
     login(request,usuario)
     if 'name' in request.COOKIES:
      if request.COOKIES['name'] == user:
       cookies = HttpResponseRedirect('/recursos/')
       expires = datetime.datetime.strftime(datetime.datetime.utcnow(), 
          "%a, %d-%b-%Y %H:%M:%S GMT")
       cookies.set_cookie(user,'')
       return cookies
      else:
       cookies = HttpResponseRedirect('/recursos/')
       cookies.set_cookie(user,'')
       print request.COOKIES
       return cookies
   else:
     mensaje = "Usuario y/o password incorrecto"
 FormLogins = FormLogin()
 return render(request,'login.html',{'form':FormLogins})
\end{lstlisting}
\subsubsection*{Compra elementos}
Al realizar una peticion a traves del carrito de la compra  servidor recibe una perticion que es tratada por la vista 'IndexBuy'.
\\La vista obtiene la informacion de la cookie asociada al usuario que realiza la peticion.Para cada elemento se realiza una instancia del modelo 'Buy()' en el que se guarda el contenido de la compra y asociamos esta compra al perfil del usuario.
\\Finalmente,se actualiza el tiempo de caducidad de la cookie del usuario antes de redireccionar al inicio de la web tras la finalizar al compra.
\\
\begin{lstlisting}[
frame=single,
commentstyle=\color{CadetBlue},
captionpos=b,
caption=Vista compra.]
def IndexBuy(request):
 usuario = str(request.user)
 valueCookie = json.loads(request.COOKIES[usuario])
 idUser = User.objects.get(username=usuario)
 inst_usuario = UserProfile.objects.get(user=idUser.id)
 for elemento in valueCookie:
  #creamos la instncia de la compra
  newCompra = Buy()
  newCompra.typeProducto='evento'
  newCompra.typeTicket=elemento['tipo']
  newCompra.cantidad=elemento['cantidad']
  newCompra.total=elemento['total']
  producto = Evento.objects.get(name=elemento['nproduct'])
  newCompra.save()
  newCompra.nameProduct.add(producto)
  inst_usuario.compra.add(newCompra)
 cookie = HttpResponseRedirect("/recursos/")
 expires = datetime.datetime.strftime(datetime.datetime.utcnow()
  + datetime.timedelta(seconds=0), "%a, %d-%b-%Y %H:%M:%S GMT")
 cookie.set_cookie(usuario,
  request.COOKIES[usuario], expires = expires)
 return cookie
\end{lstlisting}  
\subsection{Frond-End}
Se encarga del dise침o que la pagina tiene que tener y dotar a la web de cierta funcionalidad para que el usuario pueda interactuar con la web.Para abordar de una forma sencilla se dividi en dos secciones, una tratara del dise침o  de la web y el otro de la funcionalidad que posee. 
\subsubsection*{Buscador}
Se crea la funcion sendAjax() la cual se ejecuta cuando el usuario realice una busqueda a traves del metodo onchange de JS. Esta funcion recoge los caracteres que el usuario ha introducido validando que tengan una longitud mayor a dos caracteres.
\\Tras esto se crea un peticion Ajax a traves de Jquery.Para ello establecemos el metodo, la url, los datos de la peticion y dos funciones la primera se ejecuta cuando la peticion se realizando correctamente y el otro cuando existe un fallo
\subsubsection*{Lista Reproduccion}
Al selecciona un cantante se obtiene informacion referente a el,dentro de esta informacion encontramos los discos.A cada uno de los los discos le vinculamos.
\begin{lstlisting}[
frame=single,
commentstyle=\color{CadetBlue},
captionpos=b,
caption=Incluir elementos multimedia remotos l.]
 function loadcancion(file){
  var path='/media/'+file;
  $('#repro').attr('src',path);
  var tag = document.getElementById('repro');
  tag.oncanplaythrough  = function() {
    tag.play();
    $('#durationRepro').text(tag.duration);
    $('#stateRepro').text('reproduciendo');
    tag.onended = function(){
     $('#stateRepro').text('');
     };
    };
 }
\end{lstlisting}
\subsubsection*{Reproductor Video}
Al tener dos tipos de elementos de audio es necesario presentra correspondiente cada uno. El usuario a traves selecciona un video de la lista que acciona la funcion play\_repro() con la informacion del archivo.Si el archvio seleccionado es un archivo de video se presenta a traves de la etiqueta video de HTML y ocultamos la etiqueta iframe existente, en caso contrario se presenta el elemento con la etiqueta iframe y ocultamos la etiqueta video.
\\Es necesario utilizar dos etiquetas HTML diferentes es porque el los archivos iframe son urls de videos que se encuentra en otra pagina web mientras que los archivos de video son propios de la web.
\begin{lstlisting}[
frame=single,
commentstyle=\color{CadetBlue},
captionpos=b,
caption=Incluir elementos multimedia remotos l.]
 function play_repro(file,tipo){
  if(tipo == 'iframe'){
   $('iframe').attr("src",file);
   $("video").hide();
   $("iframe").show();
  }else{
  var path ='/media/'+file;
  $('video').attr("src",path);
  $("iframe").hide();
  $("video").show();
  }
 }
\end{lstlisting}
\subsubsection*{Galeria Imagenes}
\subsubsection*{Carrito de la compra}
\section{Demostraci칩n}
