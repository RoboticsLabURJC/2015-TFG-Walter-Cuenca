

\chapter{Codigó Practica 3} % Main appendix title

\label{Anexo3} % For referencing this appendix elsewhere, use \ref{AppendixA}}
\section{Galeria}
Definimos el modelo de cada imagen que vamos a tener 
\\ codec models . imagenes
La peticion del usuario para acceder a la galeria la definimos en el archivo views.py
\\ codecs models
La informacion se visualiza al renderizarla en el documentomento .'ccccc' 
\\ codec del html
\subsection{Funcionalidad}
Cada imagen de la galeria tiene atado el evento onclick el cual permite que al pulsar sobre la imagen se presenten dentro de una ventana emergente. En cuando al efecto conseguido se aplica el evento Modal de Boostrap el cual permite crear una nueva ventana dejando en segundo plano lo anterior.
\\ codigo del modal
\section{Cantantes}
La tabla correspondiente a los cantantes se crea en el archivo 'models.py' 
\lstset{language=, breaklines=true, basicstyle=\footnotesize}
%\lstset{numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=-2pt}
%linewidth=11cm
\begin{lstlisting}[
frame=single,
commentstyle=\color{CadetBlue},
captionpos=b,
caption=Incluir elementos multimedia remotos l.]
 class Artista(models.Model):
  name = models.CharField(max_length=100,null=True)
  linkImg = models.ImageField(upload_to="img_artist/",null=True)
  genero = models.CharField(max_length=100,null=True)
  web = models.URLField(max_length=100,null=True)
  disco = models.ManyToManyField(disco)
  videos = models.ManyToManyField(Videos) 
  galeria = models.ManyToManyField(Imagenes)
  def __unicode__(self):
	 return self.name
\end{lstlisting}
Cuando el cliente realiza la peticion sobre un determinado cantante el servidor consulta la funcion 'EventSelect'  la cual recibe como parametro la peticion y el nombre del evento seleccionado
\begin{lstlisting}[
frame=single,
commentstyle=\color{CadetBlue},
captionpos=b,
caption=Incluir elementos multimedia remotos l.]
 def EventSelect(request,evento):
	event = Evento.objects.filter(name__startswith=evento)
	context = {'event':event}
	return render(request,'IndexEvent.html',context)
\end{lstlisting}
La informacion que obtenemos se renderizara en la plantilla 'indexEvent.html' en el cual se presentan los distintos campos de los que dispone el elemento seleccionado.
\lstset{language=, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[
frame=single,
commentstyle=\color{CadetBlue},
captionpos=b,
caption=Incluir elementos multimedia remotos l.]
 {% extends 'IndexApp.html' %}
	{% block body %}
		{% for evento in event %}
		<div class="row">
			<div class="col-sm-12">
				<h1>{{evento.name}}</h1>
			</div>
		</div>
		 <div class="row">
    <div class="col-sm-6">
      <img src ='/media/{{evento.cartel}}' width=350px height=500px>
    </div>
			<div class="col-sm-6">
				<h3>Informacion</h3>
				<p>Lugar:{{evento.direcccion}}</p>
				<p>Fecha:{{evento.fecha.date}}</p>
				<p>Apertura de puertas:{{evento.fecha.time}}</p>
				<h3>Entradas</h3>
				<div id='ticket'>
				{% for tick in evento.entradas.all %}
					<p>{{tick.tipo}}</p>
					<p>Precio:{{tick.precio}}</p>
					<p>info:{{tick.info}}</p>
					<input id='Ticket{{tick.tipo}}' type='number' min=1 placeholder='Num.entradas' value=1>
					<br>
					<a href='tickets/'>Buy</a>
					<br>
					<button  type="button" class="btn btn-info btn-xs"  
					onclick="Anadir('{{evento.cartel}}','{{evento.name}}','{{request.user}}','{{tick.tipo}}','{{tick.precio}}','Ticket{{tick.tipo}}')">Add Car</button>
					<br>
					{% endfor %}
				</div>
			</div>
		</div>
		
	<div class="row">
  <div class="col-sm-12">
			<h3>Map Concierto</h3>
			<button  type="button" class="btn btn-info btn-xs" onclick = 'initMap("{{evento.latitud}}","{{evento.longitud}}")'>Ver Map</button>
			<div id="mapholder" style="width:700px;height:250px;"></div>
  </div>
	</div>
	<h3>Cantantes</h3>
	<div class="row">
	{% for cantante in evento.artistas.all %}
  <div class="col-md-2">
			<a href="pulpitrock.jpg" class="thumbnail">
  	<p>{{cantante.name}}</p>
   <img src='/media/{{cantante.linkImg}}' style="width:100px;height:100px">
			</a>
		</div>
	{% endfor %}
</div>
{% endfor %}
{% endblock %}
\end{lstlisting}

\subsubsection{Funcionalidad}
Una vez se ha cargado la pagina puede acceder a dos tipos de contenido. Uno de ellos es cargar un mapa del sitio donde se celebrara el  evento.Para esto utilizamos la aplicacion de  google maps diseñada para javascript que nos descargamos  atravez de un script con una clave que lo podemos generar en la web de google.
\lstset{language=, breaklines=true, basicstyle=\footnotesize}
%\lstset{numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=-2pt}
%linewidth=11cm
\begin{lstlisting}[
frame=single,
commentstyle=\color{CadetBlue},
captionpos=b,
caption=Incluir elementos multimedia remotos l.]
 <script src="https://maps.googleapis.com/maps/api/js?key=Mykey"></script>
\end{lstlisting}
Cuando el usuario pulse el boton 'mapa' se  ejecuta el evento 'onclik' que activa la funcion 'Initmap' que se encagar de crear un mapa con la longitud y latitud que recibe la funcion.
\\La biblioteca no solo nos permite crear un mapa sino tambien se puede generar contenido dentro del mapa como marcadores o ventanas de informacion.
El intercambio de informacion entre web y la biblioteca se realizar a traves de pequeños fragmentos de datos en formato JSON.
\lstset{language=, breaklines=true, basicstyle=\footnotesize}
%\lstset{numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=-2pt}
%linewidth=11cm
\begin{lstlisting}[
frame=single,
commentstyle=\color{CadetBlue},
captionpos=b,
caption=Incluir elementos multimedia remotos l.]
 function initMap(latitud,longitud) {
  var place = {lat:parseFloat(latitud),lng:parseFloat(longitud)};
  var map = new google.maps.Map(document.getElementById('mapholder'), {
    center: place,
    scrollwheel: false,
    zoom: 10
  });
  var marker = new google.maps.Marker({
   position: place,
   map: map,
   title: 'Concierto',
   draggable: true,
   animation: google.maps.Animation.DROP,
  });
  var contentString ='Localizacion del concierto';
  // Creamos una venta de informacion
  var infowindow = new google.maps.InfoWindow({
    content: contentString
  });
  // Anadimos un evento al marker
  marker.addListener('click', function() {
     infowindow.open(map, marker);
   });
 }
\end{lstlisting}
\section{Videos}
La  tabla que define un video se crea dentro del archivo 'models.py'
\lstset{language=, breaklines=true, basicstyle=\footnotesize}
%\lstset{numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=-2pt}
%linewidth=11cm
\begin{lstlisting}[
frame=single,
commentstyle=\color{CadetBlue},
captionpos=b,
caption=Incluir elementos multimedia remotos l.]
 class Videos(models.Model):
  TYPE_FILE = (
        ('iframe', 'iframe'),
        ('video', 'video'),
    )
  name = models.CharField(max_length=100,null=True)
  tipo=models.CharField(max_length=6, choices=TYPE_FILE,null=True)
  linkVideo = models.FileField(upload_to = 'video/', max_length=200,null=True,blank=True)
  linkweb = models.URLField(max_length=100,null=True,blank=True)
  def __unicode__(self):
    return self.name
\end{lstlisting}
El usuario realiza un peticion para ver todos lo videos de los que se dispone al servidor esto se reaiza por medio de la funcion 'IndexView'
\lstset{language=, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[
frame=single,
commentstyle=\color{CadetBlue},
captionpos=b,
caption=Incluir elementos multimedia remotos l.]
 def IndexView(request):
   list_video=Videos.objects.all()
   return render(request,'fullVideo.html',{'list_video':list_video})
\end{lstlisting}
Los videos se renderizan en el documento 'fullVideo.html',aqui es donde se verifica el que clase de archivo es ya que disponemos de urls de video y ficheros propocios de la web en formato 'mp4'.
Se genera una lista de videos que al pulsar se carga  el contenido dentro del tag <video> o <iframe> segun corresponda 
\lstset{language=, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[
frame=single,
commentstyle=\color{CadetBlue},
captionpos=b,
caption=Incluir elementos multimedia remotos l.]
 {% extends 'IndexApp.html' %}
  {% block body %}
    <div class="row">
	  <div class="col-sm-12">
	   <h1>Videos</h1>
	  </div>
	 </div>
     <div class="row">
       <div class="col-sm-2">
	   <ul id='listVideo' class="nav nav-pills nav-stacked">
		{% for video in list_video %}
		  {% if video.tipo == 'iframe' %}
		    <li onclick='play_repro("{{video.linkweb}}","{{video.tipo}}")'>{{video.name}}</li>
		   {% else %}
	         <li onclick='play_repro("{{video.linkVideo}}","{{video.tipo}}")'>{{video.name}}</li>
		    {% endif %}
		{% endfor %}
	  </ul>
 </div>
 <div class="col-sm-10">
  <div class="embed-responsive embed-responsive-16by9">
   <iframe target="_parent" class="embed-responsive-item" src="" frameborder="0" allowfullscreen></iframe>
  <video controls class="embed-responsive-item" src="" style='display:none' />
   </div>
 </div>
  </div>
{% endblock %}
\end{lstlisting}

\section{Eventos}
La definicion de la tabla Eventos que utilizaremos 
\\model eventos
Cuando el usuario selecciona un determinado evento el servidor ejecuta la funcion '222' en la que se realiza una consulta con el nombre del usuario.
\\ codes view
El contenido se renderiza en el documneto 'xxxx'. Dividimos la informacion en distintas secciones  donde cargamos la informacion , discos y canciones del cantante
\subsection{Funcionalidad}
En la seccion de musica del cantante cada uno de los discos tiene atado el evento onclick mediante el cual se crea una lista de reproduccion con las canciones que del disco. 
\\Al pulsar en una de las canciones se activa la funcion '' que carga la cancion seleccionada utilizando el evento ' ' de la etiqueta <audio>.

\section{Gestion de Usuarios}
La web permite a los usuarios registrarse  realizar login y logout. Para gestionar los usuarios utilizaremos el tabla User que Django tiene predefinida.
\subsection{Registro}
El usuario al pulsar en enlace register realiza una peticion al servidoir el cual ejecuta la funcion 'mmmm' en la cual se evalua el metodo con el que se realiza la peticion ya que si es 'GET' se envia al usuario el formulario de registro mientras que si es 'POST' indica que el usuario envia informacion y  creamos un nuevo usuario.
\subsection{Login}
Cuando se pulsa el  login  se envia una peticion que ejecua la funcion 'rrrr' la cual evalua el metodo de la peticion si es 'GET' enviamos el formulario vacio mientras que si es 'POST' obtenemos la informacion del  usario para realizar validaciones sobre esta informacion.
\subsection{Logout}
Cerramos la sesion que este abierto en ese momento.
\\codec logout 
\section{Perfil Usuarios}
Para poder crear perfiles para los usuario lo primero es modificar el archivo 'setting.py' en el cual se incluyendo la siguiente linea
\\setting 
\\Definimos los datos que va a tener la tabla de perfiles que utilizaremos
\\modelo
\\Se genera un perfil en el momento en el que el usuario se registra en el sitio Web. Para ello cuando el cliente envia el formulario de registro la funcion correspondiente del archivo 'view.py' se encarga de guardar la informacion en el perfil.
\\view
\subsection{Funcionalidad}
El usuario  puede consultar o modificar los datos referentes a su perfil.
\\ En la consulta obtenemos la informacion del usuario con la funcion 'xxxx', la cual con el nombre del usuario realizamos una consulta en la tabla User que nos devuelve el pk del usuario con este valor realizamos la consulta en la tabla Perfil y enviamos el resultado al usuario.Es necesario realizar una consula previa en la tabla Perfil ya que se definio que el campo nombre depende de la tabla User pero no se guarda el nombre sino su pk.
\\codec sse perfil
\\En la modificacion de datos la consulta se realiza de la misma forma que en el caso anterior pero al enviar la informacion se crea un formulario del objeto Perfil con la informacion obtenida.
\\ codece del modelo
\\Cuando el usuario modifica los datos estos se envian al servidor para almacenar la nueva informacion del perfil
\\ actualizacion codigo
\section{Contacta}
Para enviar informacion al servidor por parte del usuario lo puede mediante un formulario.Para ello se envia un formulario vacion con los campos disponibles para rellenar una vez el usuario envia el contenido este sera guardado en BBDD para tener un registro de las incidencias/preguntas que el usuario a echo.
\\modelo del contacta
Cuando el usuario envia el formulario relleno este llega al servidor quien evalua que el formulario sea valido con  la funcion 'isvalid()' predefinida en el modelForm si es valido obtenemos la informacion y lo guardamos en la BBDD
\\views referent contacta








